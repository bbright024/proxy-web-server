#include <stdio.h>

#include "csapp.h"
#include "cache.h"
#include "LinkedList.h"

#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400

#define E_NO_MEM 1
#define E_NO_SPACE 2

/* Global shared variables */
LinkedList ob_list;
size_t cache_size;
sem_t cache_mutex;

int remove_cache_lru(size_t min_size);

/* initialize the cache objects - must not be called more than once.
 * 
 * Returns 0 on success, -E_NO_MEM on failure
 */
int cache_init()
{
  cache_size = 0;
  ob_list = AllocateLinkedList();
  sem_init(&cache_mutex, 0, 1);
  if (!ob_list)
    return -E_NO_MEM;
  return 0;
}

/* Frees all parts of a CacheOb struct */
void free_cache_ob(CacheOb *cp)
{
  if (!cp)
    return;
  free(cp->location);
  free(cp);
}

/* Frees everything in the cache. 
 * cache_init must be called after this in order to use cache again.
 */
void cache_free_all() {
  FreeLinkedList(ob_list, (LLPayloadFreeFnPtr)free_cache_ob);
}
/* Checks the cache for the host/filename combo. if found,
 * returns 1 
 *
 * Returns 0 if not found.
 */
int check_cache(char *host, char *filename, void *obj_buf, char *type, size_t *sizep)
{
  if (NumElementsInLinkedList(ob_list) == 0) {
    printf("cache is empty! nothing to be searched for\n");
    return 0;
  }
    
  printf("\nSEARCHING cache:\n obj = %p \nhost = %s \nfile = %s \n", obj_buf,
	  host, filename);  
  CacheOb *op;
  P(&cache_mutex);
  LLIter iter = LLMakeIterator(ob_list, 0);
  do {
    LLIteratorGetPayload(iter, (void **)&op);
    //    printf("the gotten CacheOb info: \n");
    //    printf("filename saved as %s\n", op->filename);
    //    printf("host saved as %s\n", op->host);
    //    printf("size saved as %d\n", op->size);
    if(!strcmp(op->filename, filename) && !strcmp(op->host, host)) {
      /* found the file */
      printf("found the file\n");
      //LLIteratorMoveToHead(iter);
      LLIteratorFree(iter);
      strncpy(type, op->type, MAXLINE);
      *sizep = op->size;
      memcpy(obj_buf, op->location, op->size);
      printf("info after finding file:\n");
      printf("type = %s\n", op->type);
      printf("size = %u\n", op->size);
      V(&cache_mutex);
      return 1;
    }
  }  while (LLIteratorNext(iter));

  V(&cache_mutex);
  LLIteratorFree(iter);
  printf("did not find the file\n");
  return 0;
}

/* Adds an object to the cache.
 * - removes the last obj on linked list if cache is full
 * - pushes new obj to front
 * - locks access to the ll and cache_size
 * - fails if size is above MAX_OBJECT_SIZE, or if any parameters are invalid.
 * - uses LLIterator to delete from end of list if needed (SliceLinked needs payloadptr)
 *
 * Returns 0 on success, -E_NO_MEM or -E_NO_SPACE or -3 on other errors
 */
int add_to_cache(void *object, size_t size, char *host, char *filename, char *type)
{
  printf("trying to add to cache now\n");
  if (!object || !host || !filename || !size || !type)  {
    return -E_NO_SPACE;
  }  printf("made it past check one \n");
  if (strlen(host) > MAXLINE || strlen(filename) > MAXLINE ||
      size > MAX_OBJECT_SIZE || strlen(type) > MAXLINE)
    return -E_NO_SPACE;
  printf("made it past checks\n");
  CacheOb *obp;
  obp = malloc(sizeof(CacheOb));
  memset(obp, 0, sizeof(CacheOb));
  if (!obp)
    return -E_NO_MEM;
  /* allocate 'size' space for the object*/
  obp->location = malloc(size);
  if (!obp->location) {
    free(obp);
    return -E_NO_MEM;
  }

  /* store the metadata in the CacheOb struct */
  obp->size = size;
  memcpy(obp->location, object, size);
  strncpy(obp->host, host, MAXLINE);
  strncpy(obp->filename, filename, MAXLINE);
  strncpy(obp->type, type, MAXLINE);
  P(&cache_mutex);
  if (cache_size + size > MAX_CACHE_SIZE) {
    /* need to free oldest obj in list that leaves enough space*/
    if(remove_cache_lru(size) != 0) {
      /* if here, must be an error in the earlier space checks */
      V(&cache_mutex);
      return -E_NO_SPACE;
    }
  }

  PushLinkedList(ob_list, obp);
  cache_size += size;

  /* unlock access here */
  V(&cache_mutex);
  
  return 0;
}

/* Search backwards from the tail of the cache, removing the first
 * object of smaller size than the given parameter.  
 *   -reads and writes the cache, must be locked before called
 *
 * Returns 0 if successful, negative on error. */
int remove_cache_lru(size_t min_size)
{
    LLIter iter = LLMakeIterator(ob_list, 1);
    CacheOb *obp_r;
    while (1) {
      LLIteratorGetPayload(iter, (void **)&obp_r);
      if (min_size < obp_r->size)
	break;
      if(!LLIteratorPrev(iter)) /* at head of list if false */
	return -1;
    } 
    cache_size -= obp_r->size;

    if(!LLIteratorDelete(iter, (LLPayloadFreeFnPtr)free_cache_ob)) {
      /* if here, the cache is now empty */
      LLIteratorFree(iter);
      fprintf(stderr, "cache is empty\n");
      return -3;
    }
    LLIteratorFree(iter);
    return 0;
}




